<link rel="import" href="../at-core-theme/at-core-theme.html" />
<link rel="import" href="../at-form-input/at-form-input.html" />
<link rel="import" href="../at-form-checkbox/at-form-checkbox.html" />
<link rel="import" href="../at-form-lookup/at-form-lookup.html" />
<link rel="import" href="../at-form-markdown/at-form-markdown.html" />
<link rel="import" href="../at-form-codemirror/at-form-codemirror.html" />
<link rel="import" href="../at-form-password/at-form-password.html" />
<link rel="import" href="../at-form-file/at-form-file.html" />
<link rel="import" href="../at-form-image/at-form-image.html" />

<dom-module id="at-form-complex">
  <style>
    .errorDiv p {
      color: red;
      border: 1px solid gray;
      padding: 0 5px;
    }
  </style>
  <template>
    <div>
      <label>{{label}}</label>
    </div>
    <div id="insertPoint" class="ui form"></div>
    <div id="errorDiv" class="errorDiv">
    </div>
  </template>
</dom-module>

<script>
  "use strict";
  Polymer({
    is: 'at-form-complex',
    properties: {
      label: {
        type: String,
        value: ''
      },
      schema: {
        type: Object,
        value: function () {
          return {};
        },
        observer: 'schemaChanged'
      },
      value: {
        type: Object,
        value: function () {
          return {};
        },
        notify: true,
        observer: 'valueChanged'
      },
      valid: {
        type: Boolean,
        notify: true,
        value: true,
        readOnly: true
      },
      disabled: {
        type: Boolean,
        notify: true,
        value: false,
        observer: 'disabledChanged'
      }
    },
    elementsToValidate: [],
    _scopeCssViaAttr: true,
    ready: function () {},

    schemaChanged: function (newValue, odlValue) {
      var
        self = this, // used in value-changed function closures
        propertyName, // used as iteration variable
        properties, // propertis from schema
        propertyDefinition, // definition of a single property
        label, // label for the element representing the property
        codeMode = 'htmlmixed', // default code mode for
        type, // type of the property; translates to a coresponding element
        xtype, // used when type === string to specify which element should be created
        startIndex, // used for determining codeMode for at-form-codeMirror
        required, // holds value whether a property is required or not
        defaultValue, // holds the default value for the element
        regularValue, // temporary holds the value from the at-form-complex.value property
        disabledValue, // holds the disabled value for a property
        formElement = false, // holds a reference to a newly created element
        fieldDiv, // at-core-form class="field" wrapper for formElement
        p, textNode
      ;

      this.elementsToValidate = [];
      this.__clearInsertPoint();

      properties = this.schema.properties;
      if (isNullOrUndefined(properties)) {
        this.$.errorDiv.innerHTML = "";
        p = document.createElement('p');
        p.setAttribute('style-scope', 'at-form-complex');
        textNode = document.createTextNode("Error. Schema doesn't contain a 'properties' property");
        p.appendChild(textNode);
        this.$.errorDiv.appendChild(p);
      } else {
        this.$.errorDiv.innerHTML = "";
      }

      for (propertyName in properties) {
        propertyDefinition = properties[propertyName];

        // calculate the label property
        // by default label is property name
        // if title is provided in property definition, title becomes label
        // if description is provided in property definition, description becomes label
        // if both are provided title has priority
        label = propertyName;
        if (notNullOrUndefined(propertyDefinition.title)) {
          label = propertyDefinition.title;
        } else if (notNullOrUndefined(propertyDefinition.description)) {
          label = propertyDefinition.description;
        }

        // save property type in a local variable
        type = propertyDefinition.type;

        // update the type with xtype if exists
        // calculate the codeMode for at-form-codeMirror
        if (type === "string" && propertyDefinition.hasOwnProperty('xtype') && propertyDefinition.xtype !== "") {
          xtype = propertyDefinition.xtype;
          if (xtype.indexOf('-') != -1) {
            startIndex = xtype.indexOf('-');
            codeMode = xtype.substring(startIndex + 1);
            type = xtype.substring(0, startIndex);

            // mappings for code-* are
            // code-html -> htmlmixed
            // code-css -> text/css
            // code-javascript -> javascript
            // code-json -> application/json
            // code-sql -> sql
            // code-xml -> xml
            switch (codeMode) {
            case "html":
              codeMode = 'htmlmixed';
              break;
            case "css":
              codeMode = 'text/css';
              break;
            case "javascript":
              codeMode = 'javascript';
              break;
            case "json":
              codeMode = 'application/json';
              break;
            case "sql":
              codeMode = 'sql';
              break;
            case "xml":
              codeMode = 'xml';
              break;
            }
          } else {
            type = xtype;
          }
        }
        // END // calculate the codeMode for at-form-codeMirror

        // *ma* if type === string and xtype === '' but "enum": ["value1", "value2"] exists than
        // type === enum and xvaluelist = value list
        if (type === "string" && (!propertyDefinition.hasOwnProperty('xtype') || propertyDefinition.xtype === '') && propertyDefinition.hasOwnProperty('enum') && isArray(propertyDefinition.enum)) {
          type = "enum";
          propertyDefinition.xvaluelist = propertyDefinition.enum.join(',');
        }

        // determine required value
        // element is required if required property is present on propertyDefinition or propertyName is in schema.required array
        if (isString(propertyDefinition.required)) {
          propertyDefinition.required = parseBool(propertyDefinition.required);
        }
        required = propertyDefinition.required || (this.schema.required && this.schema.required.indexOf(propertyName) !== -1);

        // figure out the default value
        defaultValue = propertyDefinition.default;
        regularValue = this.value[propertyName];
        // if defaultValue exists but regular value doesn't (this.value is not set(
        if (notNullOrUndefined(defaultValue) && isNullOrUndefined(regularValue)) {
          // add defaultValue to the this.value object
          this.value[propertyName] = defaultValue;
        }

        // if property definition doesn't contain disabled property disabled value is false
        disabledValue = isNullOrUndefined(propertyDefinition.disabled) ? false : propertyDefinition.disabled;
        // if property definition contains disabled property it can be string. if its string its converted to a bool
        disabledValue = isString(disabledValue) ? parseBool(disabledValue) : disabledValue;

        // creation of elements
        var fieldDiv = document.createElement('div');
        fieldDiv.classList.add('field');

        if (isNullOrUndefined(type) || type === '') {
          console.log('Type not specified for ' + propertyName + ' property. Skipping ...');
          continue;
        }

        switch (type) {
        case "code":
          formElement = document.createElement('at-form-codemirror');
          // *ij* name is required here so when value-changed event is first fired element has its name set
          formElement.id = propertyName;

          formElement.addEventListener('value-changed', function (event) {
            self._updateDataObject(event.target.id, event.detail.value);
          });
          formElement.value = this.value[propertyName] ? this.value[propertyName] : '';

          formElement.mode = codeMode;

          break;
        case "number":
        case "string":
          // create paper-input
          formElement = document.createElement('at-form-input');
          // *ij* name is required here so when value-changed event is first fired element has its name set
          formElement.id = propertyName;

          if (type === "number") {
            formElement.type = type;
          }

          formElement.addEventListener('value-changed', function (event) {
            self._updateDataObject(event.target.id, event.detail.value);
          });

          if (this.value.hasOwnProperty(propertyName) && this.value[propertyName] !== '') {
            formElement.value = new String(this.value[propertyName] ? this.value[propertyName] : '');
          }

          break;
        case "password":
          formElement = document.createElement('at-form-password');
          // *ij* name is required here so when value-changed event is first fired element has its name set
          formElement.id = propertyName;

          formElement.addEventListener('value-changed', function (event) {
            self._updateDataObject(event.target.id, event.detail.value);
          });
          formElement.value = new String(this.value[propertyName] ? this.value[propertyName] : '');

          break;
        case "bool":
        case "boolean":
          // create at-form-checkbox
          formElement = document.createElement('at-form-checkbox');
          // *ij* name is required here so when value-changed event is first fired element has its name set
          formElement.id = propertyName;

          if (propertyDefinition['xtype'] === 'toggle') {
            formElement.toggle = true;
          }

          formElement.addEventListener('value-changed', function (event) {
            self._updateDataObject(event.target.id, event.detail.value);
          });
          formElement.value = this.value[propertyName] ? this.value[propertyName] : '';

          break;
        case "enum":
          formElement = document.createElement('at-form-lookup');
          // *ij* name is required here so when value-changed event is first fired element has its name set
          formElement.id = propertyName;

          formElement.available = propertyDefinition['xvaluelist'];

          formElement.addEventListener('value-changed', function (event) {
            self._updateDataObject(event.target.id, event.detail.value);
          });
          formElement.value = this.value[propertyName] ? this.value[propertyName] : '';

          break;
        case "lookup":
          formElement = document.createElement('at-form-lookup');
          // *ij* name is required here so when value-changed event is first fired element has its name set
          formElement.id = propertyName;

          formElement.url = propertyDefinition['xurl'];
          if (formElement.url !== undefined) {
            formElement.setAttribute('params', '{"query":""}');
          }

          if (propertyDefinition['noCredentials'] !== undefined) {
            formElement.setAttribute('noCredentials', true);
          }

          formElement.addEventListener('value-changed', function (event) {
            self._updateDataObject(event.target.id, event.detail.value);
          });
          formElement.value = this.value[propertyName] ? this.value[propertyName] : '';

          break;
        case "marked":
          formElement = document.createElement('at-form-markdown');
          // *ij* name is required here so when value-changed event is first fired element has its name set
          formElement.id = propertyName;

          formElement.addEventListener('value-changed', function (event) {
            self._updateDataObject(event.target.id, event.detail.value);
          });
          formElement.value = this.value[propertyName] ? this.value[propertyName] : '';

          break;
        case "file":
          formElement = document.createElement('at-form-file');
          // *ij* name is required here so when value-changed event is first fired element has its name set
          formElement.id = propertyName;

          formElement.addEventListener('value-changed', function (event) {
            self._updateDataObject(event.target.id, event.detail.value);
          });
          break;
        case "image":
          formElement = document.createElement('at-form-image');
          // *ij* name is required here so when value-changed event is first fired element has its name set
          formElement.id = propertyName;

          formElement.addEventListener('value-changed', function (event) {
            self._updateDataObject(event.target.id, event.detail.value);
          });
          break;
        }
        // end of switch here
        var classesToAdd = propertyName.split(' ');
        for (var classesToAddIndex = 0; classesToAddIndex < classesToAdd.length; classesToAddIndex += 1) {
          if (classesToAdd[classesToAddIndex] !== '') {
            formElement.classList.add(classesToAdd[classesToAddIndex]);
          }
        }

        formElement.label = label;
        formElement.disabled = disabledValue;
        formElement.required = required;
        if (required) {
          this.elementsToValidate.push(formElement);
        }

        // append paper element to its container
        fieldDiv.appendChild(formElement);
        // add container to as child to insertPoint
        this.$.insertPoint.appendChild(fieldDiv);

        // create an entry for the property in at-form-complex.value
        this.value[propertyName] = formElement.value;
      }

      // udpate the disabled status
      this.disabledChanged(this.disabled, this.disabled);
    },

    /* *ij*
     OK. Imperative data binding doesn't work in polymer anymore.
     It may happen in the future but not in near future.
     Using at-core-form.data[field] = 'newValue' doesn't work. Its not possible to bind to at-core-form.data[field] to update field value automatically
     Explained in https://github.com/Polymer/polymer/issues/1778 and https://github.com/Polymer/polymer/issues/1796

     So, to solve this shortcoming a updateFormElementData function is introduced
     The purpose of this function is, obviously, to update a value of the specific field.
     This function will update the .data object and .value of the field with provided elementId.
     If the field with provided elementId doesn't exist a debug message will be loged in the console

     Alternative to this approach is to create a completely new object each time you want to update the .data property
     IMO, this approach is a waste of time. An updateFormElementData function is much more efficient

     Another alternative to this approach is to have a function that will return the element itself. Than the client can do whatever he likes with the element
     not just update value. This approach seems reasonable for setFieldState action in at-form-rule-edit
     */
    updateFormElementData: function (elementId, data) {
      if (this.data.hasOwnProperty(elementId)) {
        // if element exists update its value
        this.data[elementId] = data;
        var element = this.$.insertPoint.querySelector('#' + elementId)
        if (element) {
          element.value = data;
        }
      } else {
        // if not log the debug message
        console.debug('Field with id: ' + elementId + ' doesn\'t exist in form.');
      }
    },

    setElementState: function (elementId, state, value) {
      var element = this.$.insertPoint.querySelector('#' + elementId);
      if (element) {
        element.setAttribute(state, value);
      } else {
        // if not log the debug message
        console.debug('Field with id: ' + elementId + ' doesn\'t exist in form.');
      }
    },

    valueChanged: function (newValue, oldValue) {
      var oldValueEntry,
        entry,
        element;

      for (oldValueEntry in oldValue) {
        if (isNullOrUndefined(this.value[oldValueEntry])) {
          this.value[oldValueEntry] = oldValue[oldValueEntry];
        }
      }


      for (entry in this.value) {
        element = Polymer.dom(this.$.insertPoint).querySelector('#' + entry);
        if (element) {
          if (notNullOrUndefined(this.value[entry])) {
            try {
              element.value = this.value[entry];
            } catch (event) {
              console.log(event);
            }
          }
        }
      }

      //this.validate(); // this was commented out for #621; it is unclear if this line should be deleted right now (19.05.2015)

      if (notNullOrUndefined(oldValue) && Object.keys(oldValue).length > 0) {
        this.fire('value-changed', {
          value: this.value
        });
      }
    },

    /*
     * This function is called on value-changed event for each element on the form
     * property is property name
     * value is the new value to be set
     */
    _updateDataObject: function (property, value) {
      this.value[property] = value;
      this.validate();
      this.fire('value-changed', {
        value: this.value
      });
    },

    /*
     * Validates the form
     * It calls validate method of each element in elementsToValidate array
     * Form is valid if all elements are valid. Form is invalid if at least one element is invalid.
     */
    validate: function () {
      var isValid = true;

      for (var i = 0; i < this.elementsToValidate.length; i++) {
        var element = this.elementsToValidate[i];
        if (isFunction(element.validate)) {
          var elementValid = element.validate();
          isValid = isValid && elementValid;
        }
      }

      this._setValid(isValid);

      return isValid;
    },


    disabledChanged: function () {
      for (var property in this.schema.properties) {
        var element = this.querySelector('.' + property);
        var disabledValue = this.disabled;
        if (this.disabled === false) {
          var elemDisabledValue = this.schema.properties[element.id].disabled;
          if (elemDisabledValue !== undefined && (elemDisabledValue === "true" || elemDisabledValue === true)) {
            disabledValue = true;
          }
        }
        element.disabled = disabledValue; // setAttribute('disabled', disabledValue);
        var childInput = element.querySelector('input');
        if (notNullOrUndefined(childInput)) {
          if (disabledValue === false) {
            childInput.removeAttribute('disabled');
          } else {
            childInput.setAttribute('disabled', true);
          }
        }
      }
    },

    // removes all child nodes of the this.$.insertPoint div
    __clearInsertPoint: function () {
      var myNode = this.$.insertPoint;
      while (myNode.firstChild) {
        myNode.removeChild(myNode.firstChild);
      }
    }
  });

  function parseBool(str) {
    if (str === 'true') {
      return true;
    }
    if (str > 0) {
      return true;
    }
    return false;
  }

  function isString(obj) {
    return Object.prototype.toString.apply(obj) === Object.prototype.toString.apply("");
  }

  function isArray(obj) {
    return Object.prototype.toString.apply(obj) === Object.prototype.toString.apply([]);
  }

  function isFunction(obj) {
    return Object.prototype.toString.apply(obj) === Object.prototype.toString.apply(function () {});
  }

  function notNullOrUndefined(param) {
    return (param !== null) && (param !== undefined);
  }

  function isNullOrUndefined(param) {
    return param === null || param === undefined;
  }

  function notNullUndefinedOrEmpty(param) {
    return notNullOrUndefined(param) && (param !== '');
  }

  function isObject(obj) {
    return Object.prototype.toString.call(obj) === Object.prototype.toString.call({});
  }

  function copyPropertyValues(from, to) {
    if (isObject(from) && isObject(to)) {
      for (var property in from) {
        to[property] = from[property];
      }
    }
  }
</script>
